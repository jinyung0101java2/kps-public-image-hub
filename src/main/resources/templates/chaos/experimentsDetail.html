<!DOCTYPE html>
<html layout:decorate="~{layouts/layout}"
      xmlns:layout="http://www.ultraq.net.nz/thymeleaf/layout"
      xmlns:th="http://www.thymeleaf.org">

<div layout:fragment="content">
    <div class="sub-page" id="content">
        <article class="location">
            <ul>
                <li><a onclick="movePage(URI_CP_CHAOS_EXPERIMENTS)">Chaos</a></li>
                <li><a onclick="movePage(URI_CP_CHAOS_EXPERIMENTS)">Experiments</a></li>
            </ul>
        </article>
        <article class="base detail">
            <div class="notice">
                <div class="chaosCharts" id="chaosCharts"></div>
                <h4>Details</h4>
                <div class="table_style01">
                    <table>
                        <caption>Details</caption>
                        <colgroup>
                            <col width="20%"/>
                            <col width="80%"/>
                        </colgroup>
                        <tbody class="listTable">
                            <tr>
                                <th class="left" scope="row">Name</th>
                                <td class="left" id="name"></td>
                            </tr>
                            <tr>
                                <th class="left" scope="row">Status</th>
                                <td class="left" id="status"></td>
                            </tr>
                            <tr>
                                <th class="left" scope="row">UUID</th>
                                <td class="left" id="uid"></td>
                            </tr>
                            <tr>
                                <th class="left" scope="row">Namespaces</th>
                                <td class="left" id="namespace"></td>
                            </tr>
                            <tr>
                                <th class="left" scope="row">Created time</th>
                                <td class="left" id="createdTime"></td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                <h4>Scope</h4>
                <div class="table_style01">
                    <table>
                        <caption>Scope</caption>
                        <colgroup>
                            <col width="20%"/>
                            <col width="80%"/>
                        </colgroup>
                        <tbody class="listTable">
                        <tr>
                            <th class="left" scope="row">Namespace Selector</th>
                            <td class="left" id="namespaceSelector"></td>
                        </tr>
                        <tr>
                            <th class="left" scope="row">Label Selectors</th>
                            <td class="left box" id="labelSelectors"></td>
                        </tr>
                        <tr>
                            <th class="left" scope="row">Selected Pods</th>
                            <td class="left box" id="selectedPods"></td>
                        </tr>
                        </tbody>
                    </table>
                </div>
                <h4>Experiment</h4>
                <div class="table_style01">
                    <table>
                        <caption>Experiment</caption>
                        <colgroup>
                            <col width="20%"/>
                            <col width="80%"/>
                        </colgroup>
                        <tbody class="listTable" id="experiment">
                        <tr>
                            <th class="left" scope="row">Kind</th>
                            <td class="left" id="kind"></td>
                        </tr>
                        </tbody>
                    </table>
                </div>
                <h4>Run</h4>
                <div class="table_style01">
                    <table>
                        <caption>Run</caption>
                        <colgroup>
                            <col width="20%"/>
                            <col width="80%"/>
                        </colgroup>
                        <tbody class="listTable" id="run">
                        <tr>
                            <th class="left" scope="row">Duration</th>
                            <td class="left" id="duration"></td>
                        </tr>
                        </tbody>
                    </table>
                </div>
                <h4>Events</h4>
                <div class="table_style01">
                    <table class="eventTable">
                        <caption>Events</caption>
                        <colgroup>
                            <col width="80%"/>
                            <col width="20%"/>
                        </colgroup>
                        <thead>
                        <tr>
                            <th scope="col">Message</th>
                            <th scope="col">Event Time</th>
                        </tr>
                        </thead>
                        <tbody class="scrollTableList">
                        </tbody>
                    </table>
                </div>
            </div>
            <!-- btn -->
            <div class="btn02">
                <button id="delete" th:text="#{M0026}" type="submit"></button>
                <div>
                    <a onclick="movePage(URI_CP_CHAOS_EXPERIMENTS)" th:text="#{M0028}"></a>
                </div>
            </div>
        </article>
    </div>
</div>
<div layout:fragment="modal">
    <div class="modal-wrap" style="display:none;">
        <div class="modal">
            <h5 th:text="#{M0034}"></h5>
            <p th:text="#{M0018}"></p>
            <button class="confirm" th:text="#{M0026}" type="submit"></button>
            <a class="close" href="javascript:" th:text="#{M0023}"></a>
        </div>
    </div>
</div>
<th:block layout:fragment="script">
    <!-- ChartJS -->
    <script src="/plugins/chart.js-3.8.0/package/dist/chart.min.js"></script>
    <script>
        const Utils = {
            CHART_COLORS: ['rgba(255, 99, 132, 1)', 'rgba(54, 162, 235, 1)', 'rgba(255, 206, 86, 1)',  'rgba(75, 192, 192, 1)', 'rgba(255, 159, 64, 1)', 'rgba(153, 102, 255, 1)', 'rgba(201, 203, 207, 1)'],
            transparentize(color, opacity) {
                const alpha = opacity === undefined ? 0.5 : 1 - opacity;
                if (typeof color !== 'string') {
                    throw new Error('color must be a string');
                }
                return color.replace(/rgba?\((\d+), (\d+), (\d+),?\s*([\d\.]+)?\)/, (match, r, g, b) => {
                    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
                });
            },
            numbers(cfg) {
                const { min, max, count } = cfg;
                const result = [];
                for (let i = 0; i < count; ++i) {
                    result.push(Math.floor(Math.random() * (max - min + 1)) + min);
                }
                return result;
            },
        };
    </script>
    <script type="text/javascript">
        window.onload = () => {
            func.init(ASIDE_DP1.CHAOS, ASIDE_DP2.EXPERIMENTS);
            const experimentsDetail = {
                statusList: [sessionStorage.getItem('uid')],
                init() {
                    // experimentsDetail 정보 조회
                    func.loadData('GET', `${func.chaosUrl}clusters/${sessionStorage.getItem('cluster')}/namespaces/${sessionStorage.getItem('chaosNamespace')}/experiments/${sessionStorage.getItem('kind')}/${sessionStorage.getItem('name')}`, 'application/json', experimentsDetail.draw);
                },

                draw(data) {
                    // Details data
                    document.getElementById('name').innerText = sessionStorage.getItem('name');
                    document.getElementById('uid').innerText = sessionStorage.getItem('uid');
                    document.getElementById('namespace').innerHTML = sessionStorage.getItem('chaosNamespace');
                    document.getElementById('createdTime').innerText = data.items[0].metadata.creationTimestamp.replace('T', ' ').replace('Z', '');

                    let experimentStatus = sessionStorage.getItem('status').toLowerCase();

                    if (experimentStatus === 'deleting' || experimentStatus === 'injecting' || experimentStatus === 'running') {
                        document.getElementById('status').innerHTML = '<span class="left experiment-' + experimentStatus + '"><span class="lds-ring"><span></span><span></span><span></span><span></span></span>' + experimentStatus.charAt(0).toUpperCase() + experimentStatus.slice(1) + '</span>';
                    } else {
                        document.getElementById('status').innerHTML = '<span class="left experiment-' + experimentStatus + '"><span class="lds-circle"><span></span></span>' + experimentStatus.charAt(0).toUpperCase() + experimentStatus.slice(1) + '</span>';
                    }

                    // Scope
                    document.getElementById('namespaceSelector').innerText = data.items[0].spec.selector.namespaces[0];

                    const labelSelectors = data.items[0].spec.selector.labelSelectors;

                    if (labelSelectors !== null) {
                        for (let i = 0; i <= Object.getOwnPropertyNames(labelSelectors).length - 1; i++) {
                            let html = `<dl><dt>${Object.getOwnPropertyNames(labelSelectors)[i]}</dt><dd>${labelSelectors[Object.keys(labelSelectors)[i]]}</dd></dl>`;
                            func.appendHtml(document.getElementById('labelSelectors'), html, 'dl');
                        }
                    } else {
                        let html = `<dl>-</dl>`;
                        func.appendHtml(document.getElementById('labelSelectors'), html, 'dl');
                    }

                    const selectedPods = data.items[0].spec.selector.pods;
                    const pods = [];
                    if(selectedPods !== null) {
                        Object.keys(selectedPods).forEach(namespace => {
                            selectedPods[namespace].forEach(pod => {
                                if(isEmpty(pods)){
                                    pods.push(pod);
                                }else {
                                    pods.push("\n" + pod);
                                }
                            })
                        })
                        document.getElementById('selectedPods').innerText = pods;

                    } else {
                        document.getElementById('selectedPods').innerText = '-';
                    }

                    // Experiment
                    document.getElementById('kind').innerHTML = data.items[0].kind;

                    if (data.items[0].kind === 'PodChaos') {
                        const action = data.items[0].spec.action;
                        const gracePeriod = data.items[0].spec.gracePeriod;

                        let html = `<tr><th scope="row" class="left">Action</th><td class="left" id="action">${action}</td></tr>`;
                        if(gracePeriod !== null){
                            html += `<tr><th scope="row" class="left">Grace Period</th><td class="left" id="gracePeriod">${gracePeriod}</td></tr>`;
                        }else {
                            html += `<tr><th scope="row" class="left">Grace Period</th><td class="left" id="gracePeriod">-</td></tr>`;
                        }
                        func.appendHtml(document.getElementById('experiment'), html, 'tbody');
                    } else if (data.items[0].kind === 'NetworkChaos') {
                        const action = data.items[0].spec.action;

                        let html = `<tr><th scope="row" class="left">Action</th><td class="left" id="action">${action}</td></tr>`;
                        func.appendHtml(document.getElementById('experiment'), html, 'tbody');
                    } else if (data.items[0].kind === 'StressChaos') {
                        // draw chart
                        if(data.items[0].experimentTime >= 30000) {
                            experimentsDetail.drawChart();
                            const namespaceSelector = data.items[0].spec.selector.namespaces[0];
                            const podNames = data.items[0].spec.selector.pods[namespaceSelector];

                            // Resource usage by selected Pods during chaos
                            func.loadData('GET', `${func.chaosUrl}clusters/${sessionStorage.getItem('cluster')}/namespaces/${namespaceSelector}/experiments/resourceUsageByPod/${sessionStorage.getItem('name')}?podList=${podNames}`, 'application/json', experimentsDetail.podChart);
                            // Resource usage by workload for selected Pods during chaos
                            func.loadData('GET', `${func.chaosUrl}clusters/${sessionStorage.getItem('cluster')}/namespaces/${namespaceSelector}/experiments/resourceUsageByWorkload/${sessionStorage.getItem('name')}`, 'application/json', experimentsDetail.workloadChart);
                            // Resource usage by node during chaos
                            func.loadData('GET', `${func.chaosUrl}clusters/${sessionStorage.getItem('cluster')}/namespaces/${namespaceSelector}/experiments/resourceUsageByNode/${sessionStorage.getItem('name')}`, 'application/json', experimentsDetail.nodeChart);
                        }


                        if (data.items[0].spec.stressors.memory != null) {
                            const memoryObj = data.items[0].spec.stressors.memory;

                            let html1 = `<tr><th scope="row" class="left">Memory</th><td class="left" id="memory"></td></tr>`;
                            func.appendHtml(document.getElementById('experiment'), html1, 'tbody');

                            let memory = '';
                            for (let i = 0; i <= Object.getOwnPropertyNames(memoryObj).length - 1; i++) {
                                if (Object.getOwnPropertyNames(memoryObj)[i] !== 'oomScoreAdj') {
                                    memory += Object.getOwnPropertyNames(memoryObj)[i] + ": " + memoryObj[Object.keys(memoryObj)[i]] + "\n";
                                }
                            }
                            document.getElementById('memory').innerText = memory;
                        }

                        if (data.items[0].spec.stressors.cpu != null) {
                            const cpuObj = data.items[0].spec.stressors.cpu;

                            let html2 = `<tr><th scope="row" class="left">CPU</th><td class="left" id="cpu"></td></tr>`;
                            func.appendHtml(document.getElementById('experiment'), html2, 'tbody');

                            let cpu = '';
                            for (let i = 0; i <= Object.getOwnPropertyNames(cpuObj).length - 1; i++) {
                                cpu += Object.getOwnPropertyNames(cpuObj)[i] + ": " + cpuObj[Object.keys(cpuObj)[i]] + "\n";
                            }
                            document.getElementById('cpu').innerText = cpu;
                        }
                    }

                    // Run
                    const duration = data.items[0].spec.duration;

                    if (duration === null) {
                        document.getElementById('duration').innerHTML = 'Run continuously';
                    }
                    if (duration) {
                        document.getElementById('duration').innerHTML = duration;
                    }

                    // event 정보 조회
                    func.loadData('GET', `${func.chaosUrl}clusters/${sessionStorage.getItem('cluster')}/namespaces/${sessionStorage.getItem('nameSpace')}/experiments/events?event=True&object_id=${sessionStorage.getItem('uid')}&limit=999`, 'application/json', experimentsDetail.list);

                    experimentsDetail.event();

                },

                list(data) {
                    func.removeHtml(document.querySelector('.scrollTableList'));

                    if (data.items.length > 0) {
                        for (let i = 0; i <= data.items.length - 1; i++) {
                            let name = data.items[i].name.split('.')[0];
                            let createdTime = data.items[i].created_at.replace('T', ' ').replace('Z', '');

                            if (name === sessionStorage.getItem('name')) {
                                let html = `<tr>
                                    <td class="left eventFirstColumn">${data.items[i].message}</td>
                                    <td>${createdTime}</td>
                                </tr>`;
                                func.appendHtml(document.querySelector('.scrollTableList'), html, 'tbody');
                            }
                        }
                    } else {
                        let html = '<tr><td rowspan="2">No Data.</td></tr>';

                        func.appendHtml(document.querySelector('.scrollTableList'), html, 'tbody');
                    }
                },

                drawChart() {
                    document.getElementById('chaosCharts').innerHTML = `
                        <h4>Metrics</h4>
                        <div class="chaosChart table_style01">
                            <table>
                                <caption>Metrics</caption>
                                <colgroup>
                                    <col width="100%"/>
                                </colgroup>
                                <tbody class="listTable">
                                    <tr>
                                        <th class="left" scope="row">Resource usage by selected Pods during chaos</th>
                                    </tr>
                                </tbody>
                            </table>
                            <div class="chaosResourceList" id="chaosPodList"></div>
                            <ol id="resourceUsageByPodCharts">
                                <li>
                                    <canvas id="cpuUsageByPodChart" style="height: 300px; max-width: 100%; max-height: 100%;"></canvas>

                                </li>
                                <li>
                                    <canvas id="memoryUsageByPodChart" style="height: 300px; max-width: 100%; max-height: 100%;"></canvas>

                                </li>
                                <li>
                                    <canvas id="appStatusUsageByPodChart" style="height: 300px; max-width: 100%; max-height: 100%;"></canvas>

                                </li>
                            </ol>
                        </div>
                        <div class="chaosChart table_style01">
                            <table>
                                <caption>Metrics</caption>
                                <colgroup>
                                    <col width="100%"/>
                                </colgroup>
                                <tbody class="listTable">
                                    <tr>
                                        <th class="left" scope="row">Resource usage by workload for selected Pods during chaos</th>
                                    </tr>
                                </tbody>
                            </table>
                            <div class="chaosResourceList" id="chaosWorkloadList"></div>
                            <ol id="resourceUsageByWorkloadCharts">
                                <li>
                                    <canvas id="cpuUsageByWorkloadChart" style="height: 300px; max-width: 100%; max-height: 100%;"></canvas>
                                </li>
                                 <li>
                                    <canvas id="memoryUsageByWorkloadChart" style="height: 300px; max-width: 100%; max-height: 100%;"></canvas>
                                </li>
                            </ol>
                        </div>
                        <div class="chaosChart table_style01">
                            <table>
                                <caption>Metrics</caption>
                                <colgroup>
                                    <col width="100%"/>
                                </colgroup>
                                <tbody class="listTable">
                                    <tr>
                                        <th class="left" scope="row">Resource usage by node during chaos</th>
                                    </tr>
                                </tbody>
                            </table>
                            <div class="chaosResourceList" id="chaosNodeList"></div>
                            <ol id="resourceUsageByNodeCharts">
                                <li>
                                    <canvas id="cpuUsageByNodeChart" style="height: 300px; max-width: 100%; max-height: 100%;"></canvas>
                                </li>
                                 <li>
                                    <canvas id="memoryUsageByNodeChart" style="height: 300px; max-width: 100%; max-height: 100%;"></canvas>
                                </li>
                            </ol>
                        </div>
                    `
                },

                podChart(data) {
                    const timeList = data.items[0].time;
                    const podNameList = data.items[0].resourceName.sort((a,b) => {
                        if ( a < b) return -1;
                        if(a > b) return 1;
                        return 0;
                    });
                    const cpuUsageLists = data.items[0].cpu;
                    const memoryUsageLists = data.items[0].memory;
                    const appStatusUsageList = data.items[0].appStatus;

                    const dataId = ['cpuUsageByPodChart', 'memoryUsageByPodChart', 'appStatusUsageByPodChart'];

                    let cpuDataSets = [];
                    let memoryDataSets = [];
                    let appStatusDataSets = [];

                    const cpuMinValue = getMinY(Math.min(...cpuUsageLists.flat()));
                    const cpuMaxValue = getMaxY(Math.max(...cpuUsageLists.flat()));
                    let cpuStepSize = cpuMaxValue <= 10 ? 1 : 10;

                    const memoryMinValue = getMinY(Math.min(...memoryUsageLists.flat()));
                    const memoryMaxValue = getMaxY(Math.max(...memoryUsageLists.flat()));
                    let memoryStepSize = memoryMaxValue <= 10 ? 1 : 10;

                    const skipped = (ctx, value) => ctx.p0.skip || ctx.p1.skip ? value : undefined;

                    for(var i = 0; i < podNameList.length; i++){
                        for(var j = 0; j < timeList.length; j++) {
                            if(cpuUsageLists[i][j] < 0){
                                cpuUsageLists[i][j] = NaN;
                            }
                            if(memoryUsageLists[i][j] < 0){
                                memoryUsageLists[i][j] = NaN;
                            }
                            if(appStatusUsageList[i][j] < 0){
                                appStatusUsageList[i][j] = NaN;
                            }
                        }
                        cpuDataSets.push({
                            label: podNameList[i],
                            data: cpuUsageLists[i],
                            borderColor: Utils.CHART_COLORS[i % Utils.CHART_COLORS.length],
                            backgroundColor: Utils.transparentize(Utils.CHART_COLORS[i % Utils.CHART_COLORS.length], 0.5),
                            segment: {
                                borderColor: ctx => skipped(ctx, 'rgb(0,0,0,0.2)'),
                                borderDash: ctx => skipped(ctx, [6, 6]),
                            },
                            spanGaps: true
                        });
                        memoryDataSets.push({
                            label: podNameList[i],
                            data: memoryUsageLists[i],
                            borderColor: Utils.CHART_COLORS[i % Utils.CHART_COLORS.length],
                            backgroundColor: Utils.transparentize(Utils.CHART_COLORS[i % Utils.CHART_COLORS.length], 0.5),
                            segment: {
                                borderColor: ctx => skipped(ctx, 'rgb(0,0,0,0.2)'),
                                borderDash: ctx => skipped(ctx, [6, 6]),
                            },
                            spanGaps: true
                        });
                        appStatusDataSets.push({
                            label: podNameList[i],
                            data: [...appStatusUsageList[i]].fill(1),
                            borderColor: Utils.CHART_COLORS[i % Utils.CHART_COLORS.length],
                            backgroundColor: appStatusUsageList[i].map(value => {
                                return value === 1 ? Utils.transparentize(Utils.CHART_COLORS[i % Utils.CHART_COLORS.length], 0.5) : 'rgb(0,0,0,0.0)' ;
                            }),
                            borderWidth: 2,
                            spanGaps: true,
                            yAxisID: `y${i+1}`

                        })
                    }

                    const scalesY = {};

                    for (let i = 1; i <= podNameList.length; i++) {
                        scalesY[`y${i}`] = {
                            type: 'linear',
                            position: 'left',
                            stack: 'demo',
                            ticks: {
                                display: false
                            },
                        };
                    }


                    const appStatusOptions = {
                        responsive: true,
                        scales: {
                            x: {
                                stacked: true,
                                ticks: {
                                    autoSkip: false,
                                    maxRotation: 0,
                                    minRotation: 0,
                                    callback: function (index) {
                                        const visibleMaxCount = 5;

                                        if (index === 0 || index % Math.ceil(timeList.length / visibleMaxCount) === 0) {
                                            return this.getLabelForValue(index).split('T')[1];
                                        }

                                        return '';
                                    }
                                }
                            },
                            ...scalesY
                        },
                        plugins: {
                            legend: false,
                            title: {
                                display: true,
                                text: 'APP Status',
                                padding: {
                                    top: 10,
                                    bottom: 10
                                }
                            }
                        }
                    };

                    const charts = [
                    new Chart(
                        document.getElementById('cpuUsageByPodChart'),
                        {
                            type: 'line',
                            data: {
                                labels: timeList,
                                datasets: cpuDataSets,
                            },
                            options: {
                                responsive: true,
                                scales: {
                                    x: {
                                        ticks: {
                                            autoSkip: false,
                                            maxRotation: 0,
                                            minRotation: 0,
                                            callback: function(index) {
                                                const visibleMaxCount = 5;

                                                if (index === 0 || index % Math.ceil(timeList.length / visibleMaxCount) === 0) {
                                                    return this.getLabelForValue(index).split('T')[1];
                                                }

                                                return '';
                                            }
                                        }
                                    },
                                    y: {
                                        type: 'linear',
                                        position: 'left',
                                        stack: 'demo',
                                        min: cpuMinValue,
                                        max: cpuMaxValue,
                                        ticks: {
                                            stepSize: cpuStepSize
                                        }
                                    }
                                },
                                plugins: {
                                    legend: false,
                                    title: {
                                        display: true,
                                        text: 'CPU',
                                        padding: {
                                            top: 10,
                                            bottom: 10
                                        }
                                    }
                                }
                            },
                        }
                    ),
                    new Chart(
                        document.getElementById('memoryUsageByPodChart'),
                        {
                            type: 'line',
                            data: {
                                labels: timeList,
                                datasets: memoryDataSets,
                            },
                            options: {
                                responsive: true,
                                scales: {
                                    x: {
                                        ticks: {
                                            autoSkip: false,
                                            maxRotation: 0,
                                            minRotation: 0,
                                            callback: function(index) {
                                                const visibleMaxCount = 5;

                                                if (index === 0 || index % Math.ceil(timeList.length / visibleMaxCount) === 0) {
                                                    return this.getLabelForValue(index).split('T')[1];
                                                }

                                                return '';
                                            }
                                        }
                                    },
                                    y: {
                                        type: 'linear',
                                        position: 'left',
                                        stack: 'demo',
                                        min: memoryMinValue,
                                        max: memoryMaxValue,
                                        ticks: {
                                            stepSize: memoryStepSize
                                        }
                                    }
                                },
                                plugins: {
                                    legend: false,
                                    title: {
                                        display: true,
                                        text: 'Memory',
                                        padding: {
                                            top: 10,
                                            bottom: 10
                                        }
                                    }
                                }
                            },
                        }
                    ),
                    new Chart(
                        document.getElementById('appStatusUsageByPodChart'),
                         {
                            type: 'bar',
                            data: {
                                labels: timeList,
                                datasets: appStatusDataSets,
                            },
                            options: appStatusOptions,
                         }
                    )];

                    const chaosResourceContainer = document.getElementById('chaosPodList');
                    cpuDataSets.forEach((dataset, index) => {
                        const item = document.createElement('div');
                        item.classList.add('chaosResourceListItem');
                        item.style.cursor = 'pointer';
                        item.style.color = '#818894';

                        item.addEventListener('click', () => {
                            dataset.hidden = !dataset.hidden;

                            charts.forEach((chart) => {
                                chart.data.datasets[index].hidden = dataset.hidden;
                                chart.update();
                            });

                            if (dataset.hidden) {
                                item.style.textDecoration = 'line-through';
                            } else {
                                item.style.textDecoration = 'none';
                            }

                        });

                        const colorBox = document.createElement('div');
                        colorBox.classList.add('chaosResourceListColor');
                        colorBox.style.backgroundColor = Utils.transparentize(dataset.borderColor, 0.5);

                        const label = document.createElement('span');
                        label.textContent = dataset.label;

                        item.appendChild(colorBox);
                        item.appendChild(label);
                        chaosResourceContainer.appendChild(item);
                    });
                },

                workloadChart(data) {
                    const timeList = data.items[0].time;
                    const workloadName = data.items[0].resourceName.sort((a,b) => {
                        if ( a < b) return -1;
                        if(a > b) return 1;
                        return 0;
                    });
                    const cpuUsage = data.items[0].cpu;
                    const memoryUsage = data.items[0].memory;

                    const dataId = ['cpuUsageByWorkloadChart', 'memoryUsageByWorkloadChart'];

                    let cpuDataSets = [];
                    let memoryDataSets = [];

                    const cpuMinValue = getMinY(Math.min(...cpuUsage.flat()));
                    const cpuMaxValue = getMaxY(Math.max(...cpuUsage.flat()));
                    let cpuStepSize = cpuMaxValue <= 10 ? 1 : 10;

                    const memoryMinValue = getMinY(Math.min(...memoryUsage.flat()));
                    const memoryMaxValue = getMaxY(Math.max(...memoryUsage.flat()));
                    let memoryStepSize = memoryMaxValue <= 10 ? 1 : 10;

                    let skipped = (ctx, value) => ctx.p0.skip || ctx.p1.skip ? value : undefined;

                    for(var i = 0; i < workloadName.length; i++){
                        for(var j = 0; j < timeList.length; j++) {
                            if(cpuUsage[i][j] < 0){
                                cpuUsage[i][j] = NaN;
                            }
                            if(memoryUsage[i][j] < 0){
                                memoryUsage[i][j] = NaN;
                            }
                        }
                        cpuDataSets.push({
                            label: workloadName[i],
                            data: cpuUsage[i],
                            borderColor: Utils.CHART_COLORS[i % Utils.CHART_COLORS.length],
                            backgroundColor: Utils.transparentize(Utils.CHART_COLORS[i % Utils.CHART_COLORS.length], 0.5),
                            segment: {
                                borderColor: ctx => skipped(ctx, 'rgb(0,0,0,0.2)'),
                                borderDash: ctx => skipped(ctx, [6, 6]),
                            },
                            spanGaps: true
                        });
                        memoryDataSets.push({
                            label: workloadName[i],
                            data: memoryUsage[i],
                            borderColor: Utils.CHART_COLORS[i % Utils.CHART_COLORS.length],
                            backgroundColor: Utils.transparentize(Utils.CHART_COLORS[i % Utils.CHART_COLORS.length], 0.5),
                            segment: {
                                borderColor: ctx => skipped(ctx, 'rgb(0,0,0,0.2)'),
                                borderDash: ctx => skipped(ctx, [6, 6]),
                            },
                            spanGaps: true
                        });
                    }

                    const charts = [
                    new Chart(
                        document.getElementById('cpuUsageByWorkloadChart'),
                        {
                            type: 'line',
                            data: {
                                labels: timeList,
                                datasets: cpuDataSets,
                            },
                            options: {
                                responsive: true,
                                scales: {
                                    x: {
                                        ticks: {
                                            autoSkip: false,
                                            maxRotation: 0,
                                            minRotation: 0,
                                            callback: function(index) {
                                                const visibleMaxCount = 6;

                                                if (index === 0 || index % Math.ceil(timeList.length / visibleMaxCount) === 0) {
                                                    return this.getLabelForValue(index).split('T')[1];
                                                }

                                                return '';
                                            }
                                        }
                                    },
                                    y: {
                                        type: 'linear',
                                        position: 'left',
                                        stack: 'demo',
                                        min: cpuMinValue,
                                        max: cpuMaxValue,
                                        ticks: {
                                            stepSize: cpuStepSize
                                        }
                                    }
                                },
                                plugins: {
                                    legend: false,
                                    title: {
                                        display: true,
                                        text: 'CPU',
                                        padding: {
                                            top: 10,
                                            bottom: 10
                                        }
                                    }
                                }
                            },
                        }
                    ),
                    new Chart(
                        document.getElementById('memoryUsageByWorkloadChart'),
                        {
                            type: 'line',
                            data: {
                                labels: timeList,
                                datasets: memoryDataSets,
                            },
                            options: {
                                responsive: true,
                                scales: {
                                    x: {
                                        ticks: {
                                            autoSkip: false,
                                            maxRotation: 0,
                                            minRotation: 0,
                                            callback: function(index) {
                                                const visibleMaxCount = 6;

                                                if (index === 0 || index % Math.ceil(timeList.length / visibleMaxCount) === 0) {
                                                    return this.getLabelForValue(index).split('T')[1];
                                                }

                                                return '';
                                            }
                                        }
                                    },
                                    y: {
                                        type: 'linear',
                                        position: 'left',
                                        stack: 'demo',
                                        min: memoryMinValue,
                                        max: memoryMaxValue,
                                        ticks: {
                                            stepSize: memoryStepSize
                                        }
                                    }
                                },
                                plugins: {
                                    legend: false,
                                    title: {
                                        display: true,
                                        text: 'Memory',
                                        padding: {
                                            top: 10,
                                            bottom: 10
                                        }
                                    }
                                }
                            },
                        }
                    )];

                    const chaosResourceContainer = document.getElementById('chaosWorkloadList');
                    cpuDataSets.forEach((dataset, index) => {
                        const item = document.createElement('div');
                        item.classList.add('chaosResourceListItem');
                        item.style.cursor = 'pointer';
                        item.style.color = '#818894';

                        item.addEventListener('click', () => {
                            dataset.hidden = !dataset.hidden;

                            charts.forEach((chart) => {
                                chart.data.datasets[index].hidden = dataset.hidden;
                                chart.update();
                            });

                            if (dataset.hidden) {
                                item.style.textDecoration = 'line-through';
                            } else {
                                item.style.textDecoration = 'none';
                            }

                        });

                        const colorBox = document.createElement('div');
                        colorBox.classList.add('chaosResourceListColor');
                        colorBox.style.backgroundColor = Utils.transparentize(dataset.borderColor, 0.5);

                        const label = document.createElement('span');
                        label.textContent = dataset.label;

                        item.appendChild(colorBox);
                        item.appendChild(label);
                        chaosResourceContainer.appendChild(item);
                    });
                },

                nodeChart(data) {
                    const timeList = data.items[0].time;
                    const nodeName = data.items[0].resourceName.sort((a,b) => {
                        if ( a < b) return -1;
                        if(a > b) return 1;
                        return 0;
                    });
                    const cpuUsage = data.items[0].cpu;
                    const memoryUsage = data.items[0].memory;

                    const dataId = ['cpuUsageByNodeChart', 'memoryUsageByNodeChart'];

                    let cpuDataSets = [];
                    let memoryDataSets = [];

                    const cpuMinValue = getMinY(Math.min(...cpuUsage.flat()));
                    const cpuMaxValue = getMaxY(Math.max(...cpuUsage.flat()));

                    const memoryMinValue = getMinY(Math.min(...memoryUsage.flat()));
                    const memoryMaxValue = getMaxY(Math.max(...memoryUsage.flat()));
                    let skipped = (ctx, value) => ctx.p0.skip || ctx.p1.skip ? value : undefined;

                    for(var i = 0; i < nodeName.length; i++){
                        for(var j = 0; j < timeList.length; j++) {
                            if(cpuUsage[i][j] < 0){
                                cpuUsage[i][j] = NaN;
                            }
                            if(memoryUsage[i][j] < 0){
                                memoryUsage[i][j] = NaN;
                            }
                        }
                        cpuDataSets.push({
                            label: nodeName[i],
                            data: cpuUsage[i],
                            borderColor: Utils.CHART_COLORS[i % Utils.CHART_COLORS.length],
                            backgroundColor: Utils.transparentize(Utils.CHART_COLORS[i % Utils.CHART_COLORS.length], 0.5),
                            segment: {
                                borderColor: ctx => skipped(ctx, 'rgb(0,0,0,0.2)'),
                                borderDash: ctx => skipped(ctx, [6, 6]),
                            },
                            spanGaps: true
                        });
                        memoryDataSets.push({
                            label: nodeName[i],
                            data: memoryUsage[i],
                            borderColor: Utils.CHART_COLORS[i % Utils.CHART_COLORS.length],
                            backgroundColor: Utils.transparentize(Utils.CHART_COLORS[i % Utils.CHART_COLORS.length], 0.5),
                            segment: {
                                borderColor: ctx => skipped(ctx, 'rgb(0,0,0,0.2)'),
                                borderDash: ctx => skipped(ctx, [6, 6]),
                            },
                            spanGaps: true
                        });
                    }

                    const charts = [
                    new Chart(
                        document.getElementById('cpuUsageByNodeChart'),
                        {
                            type: 'line',
                            data: {
                                labels: timeList,
                                datasets: cpuDataSets,
                            },
                            options: {
                                responsive: true,
                                scales: {
                                    x: {
                                        ticks: {
                                            autoSkip: false,
                                            maxRotation: 0,
                                            minRotation: 0,
                                            callback: function(index) {
                                                const visibleMaxCount = 6;

                                                if (index === 0 || index % Math.ceil(timeList.length / visibleMaxCount) === 0) {
                                                    return this.getLabelForValue(index).split('T')[1];
                                                }

                                                return '';
                                            }
                                        }
                                    },
                                    y: {
                                        type: 'linear',
                                        position: 'left',
                                        stack: 'demo',
                                        min: cpuMinValue,
                                        max: cpuMaxValue,
                                        ticks: {
                                            stepSize: 100
                                        }
                                    }
                                },
                                plugins: {
                                    legend: false,
                                    title: {
                                        display: true,
                                        text: 'CPU',
                                        padding: {
                                            top: 10,
                                            bottom: 10
                                        }
                                    }
                                }
                            },
                        }
                    ),
                    new Chart(
                        document.getElementById('memoryUsageByNodeChart'),
                        {
                            type: 'line',
                            data: {
                                labels: timeList,
                                datasets: memoryDataSets,
                            },
                            options: {
                                responsive: true,
                                scales: {
                                    x: {
                                        ticks: {
                                            autoSkip: false,
                                            maxRotation: 0,
                                            minRotation: 0,
                                            callback: function(index) {
                                                const visibleMaxCount = 6;

                                                if (index === 0 || index % Math.ceil(timeList.length / visibleMaxCount) === 0) {
                                                    return this.getLabelForValue(index).split('T')[1];
                                                }

                                                return '';
                                            }
                                        }
                                    },
                                    y: {
                                        type: 'linear',
                                        position: 'left',
                                        stack: 'demo',
                                        min: memoryMinValue,
                                        max: memoryMaxValue,
                                        ticks: {
                                            stepSize: 100
                                        }
                                    }
                                },
                                plugins: {
                                    legend: false,
                                    title: {
                                        display: true,
                                        text: 'Memory',
                                        padding: {
                                            top: 10,
                                            bottom: 10
                                        }
                                    }
                                }
                            },
                        }
                    )];

                    const chaosResourceContainer = document.getElementById('chaosNodeList');
                    cpuDataSets.forEach((dataset, index) => {
                        const item = document.createElement('div');
                        item.classList.add('chaosResourceListItem');
                        item.style.cursor = 'pointer';
                        item.style.color = '#818894';

                        item.addEventListener('click', () => {
                            dataset.hidden = !dataset.hidden;

                            charts.forEach((chart) => {
                                chart.data.datasets[index].hidden = dataset.hidden;
                                chart.update();
                            });

                            if (dataset.hidden) {
                                item.style.textDecoration = 'line-through';
                            } else {
                                item.style.textDecoration = 'none';
                            }

                        });

                        const colorBox = document.createElement('div');
                        colorBox.classList.add('chaosResourceListColor');
                        colorBox.style.backgroundColor = Utils.transparentize(dataset.borderColor, 0.5);

                        const label = document.createElement('span');
                        label.textContent = dataset.label;

                        item.appendChild(colorBox);
                        item.appendChild(label);
                        chaosResourceContainer.appendChild(item);
                    });
                },

                event() {
                    let interval = setInterval(experimentsDetail.statusInterval, 1200);

                    document.getElementById('delete').addEventListener('click', (e) => {
                        func.alertPopup('DELETE', MSG_CHECK_TO_DELETE, true, MSG_CONFIRM, experimentsDetail.delete);
                        clearInterval(interval);
                    }, false);
                },

                statusInterval() {
                    // detail status 정보 조회
                   func.statusLoadData('GET', `${func.chaosUrl}clusters/${sessionStorage.getItem('cluster')}/namespaces/${sessionStorage.getItem('nameSpace')}/experiments/status/${sessionStorage.getItem('uid')}`, 'application/json', experimentsDetail.status);
                },

                status(data) {
                    let experimentStatus = data.status;

                    if (experimentStatus === 'finished') {
                        experimentStatus = 'completed'
                    }

                    if (experimentStatus === 'deleting' || experimentStatus === 'injecting' || experimentStatus === 'running') {
                        document.getElementById('status').innerHTML = '<span class="left experiment-' + experimentStatus + '"><span class="lds-ring"><span></span><span></span><span></span><span></span></span>' + experimentStatus.charAt(0).toUpperCase() + experimentStatus.slice(1) + '</span>';
                    } else {
                        document.getElementById('status').innerHTML = '<span class="left experiment-' + experimentStatus + '"><span class="lds-circle"><span></span></span>' + experimentStatus.charAt(0).toUpperCase() + experimentStatus.slice(1) + '</span>';
                    }
                },

                delete() {

                    func.saveData('DELETE', `${func.chaosUrl}clusters/${sessionStorage.getItem('cluster')}/namespaces/${sessionStorage.getItem('chaosNamespace')}/experiments/${sessionStorage.getItem('kind')}/${sessionStorage.getItem('name')}`, '', true, 'application/json', func.historyBack);
                },
            }
            experimentsDetail.init();

            function getMaxY(value) {
                if (value <= 0) {
                    return 0;
                } else if (value <= 10) {
                    return 10;
                } else if (value <= 50) {
                    return 50;
                } else if (value <= 100) {
                    return 100;
                } else if (value <= 500) {
                    return 500;
                } else if (value <= 1000) {
                    return 1000;
                } else if (value <= 1500) {
                    return 1500;
                } else if (value <= 2000) {
                    return 2000;
                } else if (value <= 2500) {
                    return 2500;
                } else if (value <= 3000) {
                    return 3000;
                } else if (value <= 5000) {
                    return 5000;
                } else if (value <= 7500) {
                    return 7500;
                } else {
                    return Math.floor(value / 1000) * 1000;
                }

            };

            function getMinY(value) {
                if (value >= 10000) {
                    return Math.floor(value / 1000) * 1000;
                } else if (value >= 7500) {
                    return 7500;
                } else if (value >= 5000) {
                    return 5000;
                } else if (value >= 3000) {
                    return 3000;
                } else if (value >= 2500) {
                    return 2500;
                } else if (value >= 2000) {
                    return 2000;
                } else if (value >= 1500) {
                    return 1500;
                } else if (value >= 1000) {
                    return 1000;
                } else if (value >= 500) {
                    return 500;
                } else if (value >= 100) {
                    return 100;
                } else if (value >= 50) {
                    return 50;
                } else if (value >= 10) {
                    return 10;
                } else if (value >= 0) {
                    return 0;
                } else {
                    return 0;
                }

            };
        }
    </script>
</th:block>
</html>
